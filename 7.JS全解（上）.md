# JS全解（上）

李爵士、赖先生、布兰登分别发明HTML、CSS、JS；

ECMAScript是纸上的标准，JS是浏览器的实现。

JS爆发：note.js bpm express.js; webback Angular React Vue;

目前世界上使用最广泛的 JS 版本（IE 6 支持的版本）是：第三版。

<br>

### 内存图与JS世界： 

一切都运行在内存中。

开机进程：按下开机键-主板通电-加载固件-加载开机程序-加载操作系统到内存。

操作系统展示给你的界面叫shell（bash也是一种shell）

浏览器的功能：发起请求，下载HTML，解析HTML，下载CSS，解析CSS，渲染界面，下载JS，解析JS，执行JS等；

功能模块：用户界面，**渲染引擎、JS引擎**、存储等。前面各功能模块一般各处于不同的线程（进程像车间、线程像流水线）

当JS需要改变样式时，通知渲染引擎进行修改，此过程称为跨线程通信。
因为DOM需要跨线程，所以较慢（线程内部运行更快）。

JS引擎：chrome用的是V8引擎，c++编写；node.js用的是v8引擎。
主要功能：编译、优化、执行、垃圾回收。

window、document、setTimeout都不是JS自身具备的功能，我们将这些功能称为运行环境，一旦把JS放进页面，就开始运行JS。
JS在哪里运行？内存。

瓜分内存：数据区（stack、heap区）（栈、堆）； stack区特点：数据顺序存放；Heap区特点：数据随机存放；

JS执行前要有什么？
要有window、console、document、对象、数组、函数；

为什么都挂在window上？因为方便，挂在window上的东西可以在任何地方直接使用。

console.dir(? ) 打出？的结构；

window变量和window对象是两个东西，前者是一个容器，存放window对象的地址，window对象是Heap里的一坨数据。
JS三座大山：this、原型、AJAX

JS执行之前运行环境就有了Object.prototype对应的对象和Array.prototype对应的对象，用来给你引用。当创建对象，对象中含有的__proto__属性（隐藏属性）存储的地址，该地址指向Object.prototype对应的对象，因此该新建对象可以使用Object.prototype指向对象的属性；当创建数组，~ Array. prototype ~。
xxx.prototype存储了xxx对象的共同属性，这就是**原型**。原型让你无需重复声明共有属性，省代码，省内存。每个对象都有一个隐藏属性，指向原型（对象）。

我们只关心小写字母对象的隐藏属性，不关心大写字母开头的隐藏属性。__proto__和prototype拥有同样的地址，指向同样的属性（前提~），只不过prototype挂在函数（首字母大写）上，__proto__挂在每个新生对象上。
由于xxx对象到达共同属性大于两层，因此修改一个xxx对象的共同属性不会改变其他xxx对象的共同属性。

<br>

## JS语法：

ES6的发布代表JS的现代化。对待JS态度：取其精华，去其糟粕。

**表达式与语句：**

表达式一般都有值，语句可能有也可能没有；语句一般会改变环境（声明、赋值）； (值与返回值不同，只有函数有返回值。)

add(1,2) 的值为函数的返回值，console.log的值为函数本身，console.log(3) 的值为undefine。

JS对大小写敏感，大部分空格没有意义，加回车大部分时候也没影响，只有一个地方不能加回车，就是return 后面。

标识符（取名字） 第一个字符可以是Unicode字母、$ 、下划线或中文，后面的字符还可以是数字。

if语句
if(表达式) {语句一} else {语句二}

{}在语句只有一句的时候可以省略，但不建议。

e.g  
``` 
a = 1
if(a===2)
    console.log('a')
    console.log('a等于2')
```
结果：打出“a等于2”；因为下一句console不在if结构中。

“，”表示一句话没有完，“；”表示一句话完了。前后用逗号隔开的两个语句是组成一个语句。

最推荐写法：
```
if (表达式) {
语句
} else if (表达式) {
语句
} else {
语句
}
```
（次推荐写法：if语句中有return可省略所在行else ）

swith 语句（不推荐，容易用错）
```
switch () {
case “banana”……
break;
default:
}
```
三目运算符：表达式1？表达式2：表达式3 （很简洁，能用？：时就不用if-else）

&&（读-and）短路逻辑：A&&B&&C&&D取第一个假值或D，并不会取true/false。

II（读-或）短路逻辑：AIIBIICIID取第一个真值或D，并不会取true/false。

**while(表达式){语句}**

e.g
```
while(a != 1){
    console.log(a)
    a = a +0.1
}
```
上述语句为死循环 ，因为浮点数不精确，a取不到整数1。

for循环（语法糖-for是while的方便写法）

`for（语句1；表达式2；语句3）{循环体}`

e.g 
```
for(var i=0; i<5; i++){
    setTimeout (()=>{
    console.log(i)
    },0)
}
```
上述语句打出5个5。因为语句是过一会打出i。（用let声明i则会顺序打出0，1，2，3，4）

break和continue，前者跳出当前循环体，后者退出当前的一次循环。

lable语法：foo: { };
e.g {foo : 1} 左边代码什么意思？foo是一个labal，他有一个标签是1。

## 数据类型和运算符：
数字与字符串功能不同，存储形式不同。数字能加减乘除，字符串不行；字符串能表示电话号码，数字不行；JS中数字以64位浮点数形式存储，字符串用类似UTF-8形式存储。

进制转换：10→2：？*2的n次方+？*2的n次方+？*2的n次方+~ ;

2→10：从第0位开始，每一位数字都是2的？（0→n）次幂，各数相加;

2→16：<img src="/picture/transfer.jpg" width=40%/>

计算机程序员模式（HEX表示16进制；BIN表示2进制；OCT表示8进制；DEC表示10进制）

如何存储数字字符：编号，然后存储编号。

用0~127表示所有符号：48-0	65-A  97-a （48到57表示数字）；

GB2312用0000~FFFF表示汉字：一个16进制是4个0/1位，FFFF就是16位，也就是2个字节。

微软推出GBK（国标扩）；Unicode（万国码）：三个字节；UTF-8：字母汉字等采用不同存法，节省空间。

计算机不能区分你存储的是数字还是字符，需要用后缀等方法来告诉计算机。

<br>

### JS中的数据类型：
(8种)number string bool symbol  undefined null  object （四基两空一对象)

bigint(新增，提供了一种方法来表示大于 2^53 - 1 的整数。)

数组、函数、日期都不是数据类型，它们都属于object。

number特殊值：0、+0、-0 ；1/0=+∞(infinity)，1/+0=+∞，1/-0=-∞。

NaN（not a number）表示不能表示的数字，NaN本身是一个数字。NaN === NaN（False）。

64位存储一个number：符号占1位，指数占11位（-1023~1024）,有效数字占52位（开头的1省略）。

e.g  0.625如何存储：0.625=0.5+0.125 =1*2(-1)+1*2(-3)=0.101=1.01*(-1)=0  -1  01。

范围和精度：max（1e308）、min（5e-324）；精度：53个二进制位表示有效数字，2^53对应10进制是9后面15个零。

字符串：JS中每个字符两个字节，所用为阉割版UTF-8。

引号不属于字符串的一部分，就像书名号不属于书名的部分。

引号中打引号：引入斜杠\（转义）或 结合引号、双引号、反引号。

在字符串里回车：用反引号将字符串包住。

转义：用另一种写法表示你想要的东西。
```
\'表示'
\"表示"
\n表示换行
\r表示回车
\t表示tab制表符
\\表示\
\uFFFF表示对应的Unicode字符
\xFF表示前256个Unicode字符
```

只有对象有属性，其他数据类型没有。 但由于某些原因，这里学习字符串属性：

字符串长度：string.length (‘’ 与‘ ’不同，‘ ’长度为1，“//////”长度为3)

通过下标读取长度：string[index]，注意index从0开始。

base64转码：window.btoa编码，window.atob反编码。

JS中五个falsy值（即相当于false但又不是false的值）：**undefined null 0 NaN  ‘’**。

#### 三种变量声明方式：

var （旧的不好用的方式）

let （新的更合理的方式）

const a=1 （声明时必须赋值，且所赋值不能更改）（声明常量）

a=1（错误的声明方式）

let、const声明：遵循块作用域，即使用范围不能超出{}；不能重复声明（同一作用域）；可以赋值可以不赋值；全局声明的let变量，不会变成window的属性；for循环配合let有奇效。

变量在声明的时候既指定了值又指定了类型。

#### 类型转换：

刻板方法：String(n)  Number(n)  Boolean(n)  n.tostring()

推荐方法：n+’’  n-0  !!n

 
